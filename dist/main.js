/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => NBPlugin
});
module.exports = __toCommonJS(main_exports);
var ncp = __toESM(require("child_process"));
var import_util = require("util");
var import_obsidian = require("obsidian");
var exec2 = (0, import_util.promisify)(ncp.exec);
var DEFAULT_SETTINGS = {
  runOnInterval: false,
  intervalInSecs: 30
};
var SYNC_CMD = ["nb", "sync"].join(" ");
var NBPlugin = class extends import_obsidian.Plugin {
  // TODO: Avoid parallel sync
  async isRunning(query) {
    let platform = process.platform;
    let cmd = "";
    switch (platform) {
      case "win32":
        cmd = `tasklist`;
        break;
      case "darwin":
        cmd = `ps -ax | grep ${query}`;
        break;
      case "linux":
        cmd = `ps -A`;
        break;
      default:
        break;
    }
    const { stdout } = await exec2(cmd);
    return stdout.toLowerCase().indexOf(query.toLowerCase()) > -1;
  }
  async sync() {
    if (!import_obsidian.Platform.isDesktop) {
      return new import_obsidian.Notice(
        "The mobile is not supported yet! Use this plugin on desktop only for now!"
      );
    }
    new import_obsidian.Notice("Started syncing");
    this.statusBar.setText("Syncing...");
    const res = await exec2(SYNC_CMD, {}).catch((err) => {
      new import_obsidian.Notice("Could not sync! Checkout the logs");
      console.error(err);
      return null;
    });
    if (res) {
      new import_obsidian.Notice("Sync complete!");
      this.statusBar.setText(
        `Last sync time: ${new Date().toLocaleString("en-GB")}`
      );
    }
  }
  addInterval() {
    if (this.settings.runOnInterval) {
      this.intervalId = window.setInterval(() => {
        console.info("Running `nb sync` interval time!");
        exec2(["nb", "git", "status", "--porcelain"].join(" ")).then((shouldSync) => {
          if (shouldSync.stdout.length !== 0) {
            this.sync().then(() => console.log("Sync interval done!"));
          } else {
            console.info("Got a clean working directory! No need to sync!");
          }
        }).catch((err) => {
          console.error(`nb git error!`);
          console.error(err);
        });
      }, this.settings.intervalInSecs * 1e3);
      this.registerInterval(this.intervalId);
    } else {
      window.clearInterval(this.intervalId);
    }
  }
  loadSettingBasedThings() {
    this.addInterval();
  }
  async onload() {
    this.statusBar = this.addStatusBarItem();
    await this.loadSettings();
    console.info(
      `Initial load of nb plugin with: ${JSON.stringify(this.settings)}`
    );
    this.addRibbonIcon("dice", "Run `nb sync`", async (_evt) => {
      await this.sync();
    });
    this.addSettingTab(new SampleSettingTab(this.app, this));
    this.loadSettingBasedThings();
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
    this.loadSettingBasedThings();
  }
};
var SampleSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    new import_obsidian.Setting(containerEl).setName("Runing on interval").setDesc("Running `nb sync` on an interval").addToggle((toggle) => {
      toggle.setValue(this.plugin.settings.runOnInterval);
      toggle.onChange(async (checked) => {
        this.plugin.settings.runOnInterval = checked;
        await this.plugin.saveSettings();
      });
    });
    new import_obsidian.Setting(containerEl).setName("Interval time in seconds").setDesc(
      "Running `nb sync` every x seconds. This only works if running on interval is active. (Don't put less than 30 secs)"
    ).addText((text) => {
      text.setValue(this.plugin.settings.intervalInSecs.toString());
      text.onChange(async (intervalInStr) => {
        const interval = parseInt(intervalInStr);
        this.plugin.settings.intervalInSecs = interval;
        await this.plugin.saveSettings();
      });
    });
  }
};
